"""
Blockchain Verification module for Data Marketplace.
Verifies NFT ownership on the blockchain for data access control.
"""

import os
import json
from typing import Optional, Tuple
from pathlib import Path

from web3 import Web3
from eth_account.messages import encode_defunct


# Default configuration - can be overridden via environment variables
DEFAULT_RPC_URL = os.getenv("ETH_RPC_URL", "https://eth.designernha.com")
DEFAULT_MARKET_ADDRESS = os.getenv(
    "NFT_MARKET_ADDRESS",
    "0xF0b1b2A91AF3B0a0a5389eA80bFfDC42CF86B7e3"
)

# Path to ABI file (generated by Hardhat)
ABI_PATH = os.path.join(
    os.path.dirname(os.path.dirname(__file__)),
    "nft-marketplace-llm/artifacts/contracts/NFTMarket.sol/NFTMarket.json"
)


class BlockchainVerifier:
    """
    Verifies NFT ownership and data integrity on the blockchain.
    Uses Web3.py to interact with the NFTMarket smart contract.
    """

    def __init__(
        self,
        rpc_url: str = DEFAULT_RPC_URL,
        market_address: str = DEFAULT_MARKET_ADDRESS,
        abi_path: str = ABI_PATH
    ):
        """
        Initialize the blockchain verifier.

        Args:
            rpc_url: Ethereum RPC endpoint URL
            market_address: NFTMarket contract address
            abi_path: Path to contract ABI JSON file
        """
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))
        self.market_address = Web3.to_checksum_address(market_address)
        self.contract = self._load_contract(abi_path)

    def _load_contract(self, abi_path: str):
        """Load the NFTMarket contract ABI and create contract instance."""
        if os.path.exists(abi_path):
            with open(abi_path, 'r') as f:
                contract_json = json.load(f)
                abi = contract_json.get("abi", [])
        else:
            # Fallback minimal ABI for essential functions
            abi = [
                {
                    "inputs": [{"name": "itemId", "type": "uint256"}, {"name": "user", "type": "address"}],
                    "name": "verifyOwnership",
                    "outputs": [{"name": "", "type": "bool"}],
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "inputs": [{"name": "itemId", "type": "uint256"}],
                    "name": "getDataInfo",
                    "outputs": [
                        {"name": "dataHash", "type": "bytes32"},
                        {"name": "licenseType", "type": "string"},
                        {"name": "encryptedDataUrl", "type": "string"}
                    ],
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "inputs": [{"name": "marketItemId", "type": "uint256"}],
                    "name": "getMarketItem",
                    "outputs": [
                        {
                            "components": [
                                {"name": "itemId", "type": "uint256"},
                                {"name": "nftContract", "type": "address"},
                                {"name": "tokenId", "type": "uint256"},
                                {"name": "seller", "type": "address"},
                                {"name": "owner", "type": "address"},
                                {"name": "price", "type": "uint256"},
                                {"name": "dataHash", "type": "bytes32"},
                                {"name": "licenseType", "type": "string"},
                                {"name": "encryptedDataUrl", "type": "string"}
                            ],
                            "name": "",
                            "type": "tuple"
                        }
                    ],
                    "stateMutability": "view",
                    "type": "function"
                }
            ]

        return self.w3.eth.contract(address=self.market_address, abi=abi)

    def is_connected(self) -> bool:
        """Check if connected to the blockchain."""
        return self.w3.is_connected()

    def verify_ownership(self, item_id: int, wallet_address: str) -> bool:
        """
        Verify if a wallet address owns a specific marketplace item.

        Args:
            item_id: Marketplace item ID
            wallet_address: Ethereum wallet address to check

        Returns:
            True if the address owns the item, False otherwise
        """
        try:
            checksum_address = Web3.to_checksum_address(wallet_address)
            is_owner = self.contract.functions.verifyOwnership(
                item_id,
                checksum_address
            ).call()
            return is_owner
        except Exception as e:
            print(f"Error verifying ownership: {e}")
            return False

    def get_data_info(self, item_id: int) -> Optional[Tuple[str, str, str]]:
        """
        Get data information for a marketplace item.

        Args:
            item_id: Marketplace item ID

        Returns:
            Tuple of (dataHash_hex, licenseType, encryptedDataUrl) or None on error
        """
        try:
            data_hash, license_type, encrypted_url = self.contract.functions.getDataInfo(
                item_id
            ).call()
            # Convert bytes32 to hex string
            data_hash_hex = data_hash.hex()
            return data_hash_hex, license_type, encrypted_url
        except Exception as e:
            print(f"Error getting data info: {e}")
            return None

    def get_market_item(self, item_id: int) -> Optional[dict]:
        """
        Get full market item information.

        Args:
            item_id: Marketplace item ID

        Returns:
            Dict with item data or None on error
        """
        try:
            item = self.contract.functions.getMarketItem(item_id).call()
            return {
                "itemId": item[0],
                "nftContract": item[1],
                "tokenId": item[2],
                "seller": item[3],
                "owner": item[4],
                "price": item[5],
                "dataHash": item[6].hex(),
                "licenseType": item[7],
                "encryptedDataUrl": item[8]
            }
        except Exception as e:
            print(f"Error getting market item: {e}")
            return None

    def verify_data_hash(self, item_id: int, expected_hash: str) -> bool:
        """
        Verify that the data hash matches what's stored on the blockchain.

        Args:
            item_id: Marketplace item ID
            expected_hash: Expected SHA256 hash (hex string)

        Returns:
            True if hashes match, False otherwise
        """
        data_info = self.get_data_info(item_id)
        if data_info is None:
            return False

        stored_hash, _, _ = data_info
        # Remove '0x' prefix if present and compare
        stored_hash = stored_hash.lstrip('0')
        expected_hash = expected_hash.lstrip('0')
        return stored_hash == expected_hash

    def verify_signature(
        self,
        message: str,
        signature: str,
        expected_address: str
    ) -> bool:
        """
        Verify that a message was signed by the expected address.
        Used to verify that the requester controls the wallet.

        Args:
            message: The original message that was signed
            signature: The signature (hex string with 0x prefix)
            expected_address: The expected signer address

        Returns:
            True if signature is valid and from expected address
        """
        try:
            # Encode the message as per EIP-191
            message_encoded = encode_defunct(text=message)
            # Recover the address that signed the message
            recovered_address = self.w3.eth.account.recover_message(
                message_encoded,
                signature=signature
            )
            # Compare addresses (case-insensitive)
            return recovered_address.lower() == expected_address.lower()
        except Exception as e:
            print(f"Error verifying signature: {e}")
            return False

    def get_item_owner(self, item_id: int) -> Optional[str]:
        """
        Get the current owner of a marketplace item.

        Args:
            item_id: Marketplace item ID

        Returns:
            Owner address or None if item not found
        """
        item = self.get_market_item(item_id)
        if item:
            return item["owner"]
        return None

    def is_item_sold(self, item_id: int) -> bool:
        """
        Check if an item has been sold.

        Args:
            item_id: Marketplace item ID

        Returns:
            True if sold (owner != 0x0), False if unsold
        """
        owner = self.get_item_owner(item_id)
        if owner is None:
            return False
        # Item is unsold if owner is zero address
        return owner != "0x0000000000000000000000000000000000000000"
